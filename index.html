<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>CrushLite 4 â€” Upgrades, Grind Ladder, Visual Units</title>
<style>
:root{
  --bg:#070b16;
  --ink:#ecf2ff;
  --muted:#aab7dd;
  --good:#58ff9b;
  --bad:#ff5c7a;
  --warn:#ffd15c;
  --accent:#7aa8ff;
  --shadow: 0 18px 50px rgba(0,0,0,.55);
}
*{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
body{
  margin:0; height:100vh; overflow:hidden;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  color:var(--ink);
  background:
    radial-gradient(900px 600px at 50% -10%, rgba(122,168,255,.20), rgba(0,0,0,0)),
    radial-gradient(800px 500px at 20% 20%, rgba(88,255,155,.10), rgba(0,0,0,0)),
    radial-gradient(800px 500px at 80% 20%, rgba(255,92,122,.10), rgba(0,0,0,0)),
    linear-gradient(180deg, #0a1024, var(--bg));
  touch-action: manipulation;
}
.wrap{
  max-width: 1020px;
  margin:0 auto;
  height:100vh;
  padding: env(safe-area-inset-top) 10px env(safe-area-inset-bottom) 10px;
  display:flex; flex-direction:column; gap:10px;
}
.topbar{
  display:grid;
  grid-template-columns: 1fr auto auto auto auto;
  gap:10px; align-items:stretch;
}
.panel{
  background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.12);
  border-radius: 16px;
  padding:10px 12px;
  box-shadow: var(--shadow);
}
.statgrid{
  display:grid;
  grid-template-columns: repeat(6, 1fr);
  gap:10px;
}
.stat .k{font-size:11px; color:var(--muted)}
.stat .v{font-weight:900; letter-spacing:.2px}
.btn{
  user-select:none;
  cursor:pointer;
  border-radius: 16px;
  padding:10px 14px;
  min-height:44px;
  display:flex; align-items:center; justify-content:center;
  font-weight:900;
  background: linear-gradient(180deg, rgba(122,168,255,.30), rgba(122,168,255,.10));
  border:1px solid rgba(122,168,255,.38);
  box-shadow: var(--shadow);
}
.btn.secondary{
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.12);
}
.btn:active{transform: translateY(1px);}

#canvas{
  width:100%;
  flex:1;
  border-radius: 18px;
  border:1px solid rgba(255,255,255,.12);
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
  box-shadow: var(--shadow);
}

.handwrap{display:flex; flex-direction:column; gap:8px;}
.hand{display:flex; gap:8px;}
.card{
  flex:1;
  min-height:98px;
  border-radius: 18px;
  padding:10px 10px 8px;
  border:1px solid rgba(255,255,255,.12);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
  position:relative;
  overflow:hidden;
}
.card::before{
  content:"";
  position:absolute; inset:-40px -40px auto auto;
  width:120px; height:120px;
  background: radial-gradient(circle at 40% 40%, rgba(122,168,255,.22), rgba(0,0,0,0) 60%);
  transform: rotate(15deg);
}
.card.sel{
  outline: 2px solid rgba(122,168,255,.95);
  box-shadow: 0 0 0 4px rgba(122,168,255,.16), var(--shadow);
  transform: translateY(-1px);
}
.card.disabled{opacity:.55;}
.card .row1{display:flex; justify-content:space-between; gap:8px; align-items:flex-start;}
.card .name{font-weight:950; font-size:13px; line-height:1.1}
.card .sub{font-size:11px; color:var(--muted); margin-top:2px}
.portrait{
  width:34px; height:34px;
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.25);
  display:flex; align-items:center; justify-content:center;
  font-size:18px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
.badge{
  font-size:11px; font-weight:900;
  border-radius: 999px;
  padding:6px 9px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
}
.badge.mana{border-color: rgba(122,168,255,.30);}
.badge.lvl{border-color: rgba(88,255,155,.28);}
.r-unranked{color:#d9e2ff}
.r-bronze{color:#d7b07a}
.r-silver{color:#cfd8e8}
.r-gold{color:#ffd15c}
.r-platinum{color:#8ce8ff}
.r-diamond{color:#b9a6ff}
.r-emerald{color:#58ff9b}
.r-ruby{color:#ff6aa6}
.r-legendary{color:#ffcc66; text-shadow:0 0 18px rgba(255,209,92,.35)}
.r-mythic{color:#7aa8ff; text-shadow:0 0 18px rgba(122,168,255,.35)}
.r-secret{color:#ffffff; text-shadow:0 0 22px rgba(255,255,255,.35)}

.hint{text-align:center; color:var(--muted); font-size:12px;}
.pill{
  font-size:12px; font-weight:900;
  border-radius:999px;
  padding:6px 10px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
}
.pill.good{border-color: rgba(88,255,155,.25)}
.pill.bad{border-color: rgba(255,92,122,.25)}
.pill.warn{border-color: rgba(255,209,92,.25)}

.overlay{
  position:fixed; inset:0;
  background: rgba(0,0,0,.68);
  display:none; align-items:center; justify-content:center;
  padding: 16px;
  z-index: 10;
}
.modal{
  width:min(940px, 100%);
  max-height: 86vh;
  overflow:hidden;
  border-radius: 18px;
  border:1px solid rgba(255,255,255,.14);
  background: linear-gradient(180deg, rgba(15,23,48,.98), rgba(8,10,18,.98));
  box-shadow: 0 30px 90px rgba(0,0,0,.60);
}
.modal .head{
  padding:14px 14px 10px;
  display:flex; justify-content:space-between; gap:10px; align-items:center;
  border-bottom:1px solid rgba(255,255,255,.10);
}
.modal .body{
  padding: 12px 14px 14px;
  overflow:auto;
  max-height: calc(86vh - 64px);
}
.modal h2{margin:0; font-size:16px}
.modal p{margin:6px 0; color:var(--muted); line-height:1.35; font-size:13px}
.row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
.grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
.grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}
.small{font-size:12px; color:var(--muted)}
.list{
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  border-radius: 16px;
  overflow:hidden;
}
.item{
  padding:10px 10px;
  border-bottom:1px solid rgba(255,255,255,.06);
  display:flex; justify-content:space-between; gap:10px; align-items:flex-start;
}
.item:last-child{border-bottom:none}
.item .left{display:flex; flex-direction:column; gap:2px}
.item .title{font-weight:950; font-size:13px}
.item .desc{font-size:12px; color:var(--muted)}
.chip{
  font-size:11px; font-weight:950;
  padding:6px 9px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.20);
  white-space:nowrap;
}
.chip.ok{border-color: rgba(88,255,155,.25)}
.chip.lock{border-color: rgba(255,92,122,.25)}
.search{
  width:100%;
  padding:10px 12px;
  border-radius: 14px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  color:var(--ink);
  font-weight:800;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="panel">
      <div class="statgrid">
        <div class="stat"><div class="k">Rank</div><div class="v" id="rankName">Unranked</div></div>
        <div class="stat"><div class="k">Rank %</div><div class="v"><span id="rankPct">0</span>%</div></div>
        <div class="stat"><div class="k">Unlocked</div><div class="v"><span id="unlockedCount">0</span>/<span id="totalCards">0</span></div></div>
        <div class="stat"><div class="k">Gold</div><div class="v" id="gold">0</div></div>
        <div class="stat"><div class="k">Streak</div><div class="v"><span id="streak">0</span> (Best <span id="bestStreak">0</span>)</div></div>
        <div class="stat"><div class="k">Time</div><div class="v" id="timeLeft">5:00</div></div>
      </div>
    </div>
    <div class="btn secondary" id="btnChests">Chests</div>
    <div class="btn secondary" id="btnUpgrades">Upgrades</div>
    <div class="btn secondary" id="btnDeck">Deck</div>
    <div class="btn" id="btnMenu">Home</div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="handwrap">
    <div class="hand" id="hand"></div>
    <div class="hint">Tap a card â†’ tap a lane. Win for <b>chests</b> and <b>rank %</b>. Use <b>Upgrades</b> to level cards. Progress auto-saves.</div>
  </div>
</div>

<div class="overlay" id="overlay"><div class="modal" id="modal"></div></div>

<script>
(() => {
  const RANKS = [{"id": "unranked", "name": "Unranked", "winsToPromote": 2}, {"id": "bronze", "name": "Bronze", "winsToPromote": 3}, {"id": "silver", "name": "Silver", "winsToPromote": 4}, {"id": "gold", "name": "Gold", "winsToPromote": 5}, {"id": "platinum", "name": "Platinum", "winsToPromote": 6}, {"id": "diamond", "name": "Diamond", "winsToPromote": 7}, {"id": "emerald", "name": "Emerald", "winsToPromote": 8}, {"id": "ruby", "name": "Ruby", "winsToPromote": 10}, {"id": "legendary", "name": "Legendary", "winsToPromote": 14}, {"id": "mythic", "name": "Mythic", "winsToPromote": 20}, {"id": "secret", "name": "Secret", "winsToPromote": 999}];
  const CARDS = [{"id": "duelist-of-thorns-1", "name": "Duelist of Thorns 1", "rank": "unranked", "cost": 3, "kind": "unit", "hp": 256, "dmg": 45, "atkSpd": 0.75, "spd": 49, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-dawn-2", "name": "Squire of Dawn 2", "rank": "unranked", "cost": 4, "kind": "unit", "hp": 340, "dmg": 40, "atkSpd": 0.95, "spd": 34, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "guardian-of-storms-3", "name": "Guardian of Storms 3", "rank": "unranked", "cost": 4, "kind": "unit", "hp": 493, "dmg": 31, "atkSpd": 0.95, "spd": 29, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-iron-4", "name": "Squire of Iron 4", "rank": "unranked", "cost": 2, "kind": "unit", "hp": 230, "dmg": 28, "atkSpd": 0.95, "spd": 32, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-dawn-5", "name": "Squire of Dawn 5", "rank": "unranked", "cost": 3, "kind": "unit", "hp": 285, "dmg": 34, "atkSpd": 0.95, "spd": 33, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "pikeman-of-dawn-6", "name": "Pikeman of Dawn 6", "rank": "unranked", "cost": 2, "kind": "unit", "hp": 241, "dmg": 26, "atkSpd": 0.95, "spd": 32, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.35, "note": "Bonus vs tanky units (1.35x)."}, {"id": "frost-mist-of-iron-1", "name": "Frost Mist of Iron 1", "rank": "unranked", "cost": 3, "kind": "spell", "dmg": 60, "radius": 98, "slow": 0.42, "slowDur": 2.8, "note": "Damages and slows enemies."}, {"id": "spark-of-ivory-2", "name": "Spark of Ivory 2", "rank": "unranked", "cost": 2, "kind": "spell", "dmg": 106, "radius": 82, "note": "Quick burst of damage in a lane."}, {"id": "healing-light-of-shadow-3", "name": "Healing Light of Shadow 3", "rank": "unranked", "cost": 4, "kind": "spell", "heal": 190, "radius": 108, "note": "Heals allies in a lane."}, {"id": "arcane-ward-of-ash-4", "name": "Arcane Ward of Ash 4", "rank": "unranked", "cost": 4, "kind": "spell", "shieldAllies": 167, "radius": 104, "note": "Grants a temporary shield to allies in a lane."}, {"id": "pikeman-of-ash-1", "name": "Pikeman of Ash 1", "rank": "bronze", "cost": 3, "kind": "unit", "hp": 335, "dmg": 36, "atkSpd": 0.95, "spd": 37, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.4, "note": "Bonus vs tanky units (1.4x)."}, {"id": "squire-of-iron-2", "name": "Squire of Iron 2", "rank": "bronze", "cost": 3, "kind": "unit", "hp": 319, "dmg": 38, "atkSpd": 0.95, "spd": 37, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "berserker-of-the-vale-3", "name": "Berserker of the Vale 3", "rank": "bronze", "cost": 3, "kind": "unit", "hp": 351, "dmg": 43, "atkSpd": 0.9, "spd": 48, "range": 18, "archetype": "bruiser", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "guardian-of-ivory-4", "name": "Guardian of Ivory 4", "rank": "bronze", "cost": 4, "kind": "unit", "hp": 552, "dmg": 34, "atkSpd": 0.95, "spd": 33, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-dawn-5", "name": "Ranger of Dawn 5", "rank": "bronze", "cost": 3, "kind": "unit", "hp": 248, "dmg": 34, "atkSpd": 0.8, "spd": 41, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-dawn-6", "name": "Duelist of Dawn 6", "rank": "bronze", "cost": 2, "kind": "unit", "hp": 231, "dmg": 42, "atkSpd": 0.75, "spd": 53, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-ivory-7", "name": "Squire of Ivory 7", "rank": "bronze", "cost": 3, "kind": "unit", "hp": 319, "dmg": 38, "atkSpd": 0.95, "spd": 37, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "void-rift-of-shadow-1", "name": "Void Rift of Shadow 1", "rank": "bronze", "cost": 5, "kind": "spell", "dmg": 369, "radius": 118, "pull": 0.7, "note": "Pulls enemies inward and hits hard."}, {"id": "dragon-breath-of-the-deep-2", "name": "Dragon Breath of the Deep 2", "rank": "bronze", "cost": 5, "kind": "spell", "dmg": 134, "radius": 170, "dot": 49, "dotDur": 3.4, "note": "Wide lane burn: damage + burning over time."}, {"id": "dragon-breath-of-cinders-3", "name": "Dragon Breath of Cinders 3", "rank": "bronze", "cost": 3, "kind": "spell", "dmg": 98, "radius": 150, "dot": 35, "dotDur": 3.2, "note": "Wide lane burn: damage + burning over time."}, {"id": "meteor-of-frost-4", "name": "Meteor of Frost 4", "rank": "bronze", "cost": 2, "kind": "spell", "dmg": 224, "radius": 100, "stun": 0.64, "note": "Big AoE hit with a brief stun."}, {"id": "arcane-ward-of-cinders-5", "name": "Arcane Ward of Cinders 5", "rank": "bronze", "cost": 5, "kind": "spell", "shieldAllies": 218, "radius": 110, "note": "Grants a temporary shield to allies in a lane."}, {"id": "duelist-of-the-deep-1", "name": "Duelist of the Deep 1", "rank": "silver", "cost": 4, "kind": "unit", "hp": 379, "dmg": 66, "atkSpd": 0.75, "spd": 62, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "guardian-of-dawn-2", "name": "Guardian of Dawn 2", "rank": "silver", "cost": 5, "kind": "unit", "hp": 710, "dmg": 44, "atkSpd": 0.95, "spd": 37, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "pikeman-of-thorns-3", "name": "Pikeman of Thorns 3", "rank": "silver", "cost": 4, "kind": "unit", "hp": 442, "dmg": 47, "atkSpd": 0.95, "spd": 43, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.45, "note": "Bonus vs tanky units (1.45x)."}, {"id": "ranger-of-the-deep-4", "name": "Ranger of the Deep 4", "rank": "silver", "cost": 4, "kind": "unit", "hp": 328, "dmg": 44, "atkSpd": 0.8, "spd": 47, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-shadow-5", "name": "Squire of Shadow 5", "rank": "silver", "cost": 3, "kind": "unit", "hp": 353, "dmg": 42, "atkSpd": 0.95, "spd": 41, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-storms-6", "name": "Duelist of Storms 6", "rank": "silver", "cost": 5, "kind": "unit", "hp": 440, "dmg": 77, "atkSpd": 0.75, "spd": 63, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-ivory-7", "name": "Duelist of Ivory 7", "rank": "silver", "cost": 4, "kind": "unit", "hp": 379, "dmg": 66, "atkSpd": 0.75, "spd": 62, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-dawn-8", "name": "Skirmisher of Dawn 8", "rank": "silver", "cost": 3, "kind": "unit", "hp": 219, "dmg": 32, "atkSpd": 0.7, "spd": 63, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "chain-lightning-of-the-deep-1", "name": "Chain Lightning of the Deep 1", "rank": "silver", "cost": 5, "kind": "spell", "dmg": 223, "jumps": 3, "radius": 42, "note": "Bounces between up to 3 enemies."}, {"id": "silence-sigil-of-dawn-2", "name": "Silence Sigil of Dawn 2", "rank": "silver", "cost": 3, "kind": "spell", "radius": 104, "silence": 1.88, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "poison-cloud-of-cinders-3", "name": "Poison Cloud of Cinders 3", "rank": "silver", "cost": 5, "kind": "spell", "dmg": 89, "radius": 122, "dot": 65, "dotDur": 3.8, "note": "Poison cloud: damage + strong DoT."}, {"id": "arcane-ward-of-shadow-4", "name": "Arcane Ward of Shadow 4", "rank": "silver", "cost": 4, "kind": "spell", "shieldAllies": 207, "radius": 104, "note": "Grants a temporary shield to allies in a lane."}, {"id": "chain-lightning-of-the-vale-5", "name": "Chain Lightning of the Vale 5", "rank": "silver", "cost": 5, "kind": "spell", "dmg": 223, "jumps": 3, "radius": 42, "note": "Bounces between up to 3 enemies."}, {"id": "duelist-of-ash-1", "name": "Duelist of Ash 1", "rank": "gold", "cost": 6, "kind": "unit", "hp": 550, "dmg": 95, "atkSpd": 0.75, "spd": 71, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-thorns-2", "name": "Duelist of Thorns 2", "rank": "gold", "cost": 3, "kind": "unit", "hp": 348, "dmg": 62, "atkSpd": 0.75, "spd": 66, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-ash-3", "name": "Skirmisher of Ash 3", "rank": "gold", "cost": 4, "kind": "unit", "hp": 286, "dmg": 42, "atkSpd": 0.7, "spd": 70, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "berserker-of-thorns-4", "name": "Berserker of Thorns 4", "rank": "gold", "cost": 4, "kind": "unit", "hp": 508, "dmg": 62, "atkSpd": 0.9, "spd": 60, "range": 18, "archetype": "bruiser", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "pikeman-of-the-vale-5", "name": "Pikeman of the Vale 5", "rank": "gold", "cost": 6, "kind": "unit", "hp": 642, "dmg": 67, "atkSpd": 0.95, "spd": 50, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.55, "note": "Bonus vs tanky units (1.55x)."}, {"id": "guardian-of-thorns-6", "name": "Guardian of Thorns 6", "rank": "gold", "cost": 6, "kind": "unit", "hp": 887, "dmg": 55, "atkSpd": 0.95, "spd": 43, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "pikeman-of-iron-7", "name": "Pikeman of Iron 7", "rank": "gold", "cost": 5, "kind": "unit", "hp": 564, "dmg": 59, "atkSpd": 0.95, "spd": 48, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.5, "note": "Bonus vs tanky units (1.5x)."}, {"id": "ranger-of-the-vale-8", "name": "Ranger of the Vale 8", "rank": "gold", "cost": 5, "kind": "unit", "hp": 419, "dmg": 56, "atkSpd": 0.8, "spd": 53, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "poison-cloud-of-the-vale-1", "name": "Poison Cloud of the Vale 1", "rank": "gold", "cost": 5, "kind": "spell", "dmg": 97, "radius": 122, "dot": 72, "dotDur": 3.8, "note": "Poison cloud: damage + strong DoT."}, {"id": "silence-sigil-of-the-vale-2", "name": "Silence Sigil of the Vale 2", "rank": "gold", "cost": 4, "kind": "spell", "radius": 110, "silence": 2.04, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "meteor-of-dawn-3", "name": "Meteor of Dawn 3", "rank": "gold", "cost": 4, "kind": "spell", "dmg": 380, "radius": 112, "stun": 0.78, "note": "Big AoE hit with a brief stun."}, {"id": "meteor-of-frost-4", "name": "Meteor of Frost 4", "rank": "gold", "cost": 4, "kind": "spell", "dmg": 380, "radius": 112, "stun": 0.78, "note": "Big AoE hit with a brief stun."}, {"id": "spark-of-the-deep-5", "name": "Spark of the Deep 5", "rank": "gold", "cost": 4, "kind": "spell", "dmg": 220, "radius": 94, "note": "Quick burst of damage in a lane."}, {"id": "berserker-of-cinders-1", "name": "Berserker of Cinders 1", "rank": "platinum", "cost": 3, "kind": "unit", "hp": 463, "dmg": 57, "atkSpd": 0.9, "spd": 64, "range": 18, "archetype": "bruiser", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-the-vale-2", "name": "Ranger of the Vale 2", "rank": "platinum", "cost": 5, "kind": "unit", "hp": 455, "dmg": 61, "atkSpd": 0.8, "spd": 58, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-thorns-3", "name": "Duelist of Thorns 3", "rank": "platinum", "cost": 3, "kind": "unit", "hp": 379, "dmg": 67, "atkSpd": 0.75, "spd": 72, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-shadow-4", "name": "Skirmisher of Shadow 4", "rank": "platinum", "cost": 6, "kind": "unit", "hp": 412, "dmg": 60, "atkSpd": 0.7, "spd": 80, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "pikeman-of-the-vale-5", "name": "Pikeman of the Vale 5", "rank": "platinum", "cost": 6, "kind": "unit", "hp": 699, "dmg": 73, "atkSpd": 0.95, "spd": 54, "range": 18, "archetype": "anti-tank", "bonusVs": "tank", "bonusMul": 1.55, "note": "Bonus vs tanky units (1.55x)."}, {"id": "guardian-of-the-deep-6", "name": "Guardian of the Deep 6", "rank": "platinum", "cost": 6, "kind": "unit", "hp": 965, "dmg": 60, "atkSpd": 0.95, "spd": 46, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-frost-7", "name": "Squire of Frost 7", "rank": "platinum", "cost": 3, "kind": "unit", "hp": 421, "dmg": 50, "atkSpd": 0.95, "spd": 50, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "sorcerer-of-the-deep-8", "name": "Sorcerer of the Deep 8", "rank": "platinum", "cost": 4, "kind": "unit", "hp": 345, "dmg": 49, "atkSpd": 0.85, "spd": 51, "range": 150, "archetype": "control", "curse": 0.22, "note": "Curses targets: they take 22% more damage for a short time."}, {"id": "frost-mist-of-storms-1", "name": "Frost Mist of Storms 1", "rank": "platinum", "cost": 3, "kind": "spell", "dmg": 88, "radius": 98, "slow": 0.42, "slowDur": 2.8, "note": "Damages and slows enemies."}, {"id": "frost-mist-of-ash-2", "name": "Frost Mist of Ash 2", "rank": "platinum", "cost": 4, "kind": "spell", "dmg": 109, "radius": 104, "slow": 0.46, "slowDur": 3.0, "note": "Damages and slows enemies."}, {"id": "summon-imps-of-dawn-3", "name": "Summon Imps of Dawn 3", "rank": "platinum", "cost": 5, "kind": "spell", "summon": {"name": "Imp", "hp": 170, "dmg": 44, "atkSpd": 0.85, "spd": 95, "range": 16, "archetype": "swarm"}, "count": 4, "note": "Spawns 4 imps in the lane."}, {"id": "arcane-ward-of-ash-4", "name": "Arcane Ward of Ash 4", "rank": "platinum", "cost": 3, "kind": "spell", "shieldAllies": 205, "radius": 98, "note": "Grants a temporary shield to allies in a lane."}, {"id": "healing-light-of-ivory-5", "name": "Healing Light of Ivory 5", "rank": "platinum", "cost": 6, "kind": "spell", "heal": 370, "radius": 120, "note": "Heals allies in a lane."}, {"id": "meteor-of-shadow-6", "name": "Meteor of Shadow 6", "rank": "platinum", "cost": 5, "kind": "spell", "dmg": 473, "radius": 118, "stun": 0.85, "note": "Big AoE hit with a brief stun."}, {"id": "duelist-of-ivory-1", "name": "Duelist of Ivory 1", "rank": "diamond", "cost": 5, "kind": "unit", "hp": 568, "dmg": 99, "atkSpd": 0.75, "spd": 82, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-dawn-2", "name": "Skirmisher of Dawn 2", "rank": "diamond", "cost": 3, "kind": "unit", "hp": 282, "dmg": 42, "atkSpd": 0.7, "spd": 81, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-the-deep-3", "name": "Skirmisher of the Deep 3", "rank": "diamond", "cost": 6, "kind": "unit", "hp": 446, "dmg": 64, "atkSpd": 0.7, "spd": 86, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-cinders-4", "name": "Skirmisher of Cinders 4", "rank": "diamond", "cost": 3, "kind": "unit", "hp": 282, "dmg": 42, "atkSpd": 0.7, "spd": 81, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-dawn-5", "name": "Ranger of Dawn 5", "rank": "diamond", "cost": 5, "kind": "unit", "hp": 492, "dmg": 66, "atkSpd": 0.8, "spd": 63, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "berserker-of-the-deep-6", "name": "Berserker of the Deep 6", "rank": "diamond", "cost": 4, "kind": "unit", "hp": 598, "dmg": 73, "atkSpd": 0.9, "spd": 71, "range": 18, "archetype": "bruiser", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-frost-7", "name": "Squire of Frost 7", "rank": "diamond", "cost": 7, "kind": "unit", "hp": 808, "dmg": 92, "atkSpd": 0.95, "spd": 61, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-thorns-8", "name": "Duelist of Thorns 8", "rank": "diamond", "cost": 7, "kind": "unit", "hp": 727, "dmg": 125, "atkSpd": 0.75, "spd": 85, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "spark-of-iron-1", "name": "Spark of Iron 1", "rank": "diamond", "cost": 5, "kind": "spell", "dmg": 304, "radius": 100, "note": "Quick burst of damage in a lane."}, {"id": "silence-sigil-of-dawn-2", "name": "Silence Sigil of Dawn 2", "rank": "diamond", "cost": 5, "kind": "spell", "radius": 116, "silence": 2.2, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "summon-imps-of-storms-3", "name": "Summon Imps of Storms 3", "rank": "diamond", "cost": 4, "kind": "spell", "summon": {"name": "Imp", "hp": 164, "dmg": 41, "atkSpd": 0.85, "spd": 100, "range": 16, "archetype": "swarm"}, "count": 3, "note": "Spawns 3 imps in the lane."}, {"id": "dragon-breath-of-frost-4", "name": "Dragon Breath of Frost 4", "rank": "diamond", "cost": 7, "kind": "spell", "dmg": 243, "radius": 190, "dot": 89, "dotDur": 3.6, "note": "Wide lane burn: damage + burning over time."}, {"id": "summon-imps-of-iron-5", "name": "Summon Imps of Iron 5", "rank": "diamond", "cost": 5, "kind": "spell", "summon": {"name": "Imp", "hp": 184, "dmg": 48, "atkSpd": 0.85, "spd": 103, "range": 16, "archetype": "swarm"}, "count": 4, "note": "Spawns 4 imps in the lane."}, {"id": "silence-sigil-of-frost-6", "name": "Silence Sigil of Frost 6", "rank": "diamond", "cost": 7, "kind": "spell", "radius": 128, "silence": 2.52, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "sorcerer-of-frost-1", "name": "Sorcerer of Frost 1", "rank": "emerald", "cost": 7, "kind": "unit", "hp": 596, "dmg": 82, "atkSpd": 0.85, "spd": 65, "range": 150, "archetype": "control", "curse": 0.31, "note": "Curses targets: they take 31% more damage for a short time."}, {"id": "sorcerer-of-frost-2", "name": "Sorcerer of Frost 2", "rank": "emerald", "cost": 7, "kind": "unit", "hp": 596, "dmg": 82, "atkSpd": 0.85, "spd": 65, "range": 150, "archetype": "control", "curse": 0.31, "note": "Curses targets: they take 31% more damage for a short time."}, {"id": "duelist-of-ash-3", "name": "Duelist of Ash 3", "rank": "emerald", "cost": 4, "kind": "unit", "hp": 526, "dmg": 92, "atkSpd": 0.75, "spd": 86, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "berserker-of-the-deep-4", "name": "Berserker of the Deep 4", "rank": "emerald", "cost": 6, "kind": "unit", "hp": 851, "dmg": 102, "atkSpd": 0.9, "spd": 80, "range": 18, "archetype": "bruiser", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "sorcerer-of-ivory-5", "name": "Sorcerer of Ivory 5", "rank": "emerald", "cost": 6, "kind": "unit", "hp": 531, "dmg": 74, "atkSpd": 0.85, "spd": 63, "range": 150, "archetype": "control", "curse": 0.28, "note": "Curses targets: they take 28% more damage for a short time."}, {"id": "skirmisher-of-storms-6", "name": "Skirmisher of Storms 6", "rank": "emerald", "cost": 6, "kind": "unit", "hp": 479, "dmg": 69, "atkSpd": 0.7, "spd": 93, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "guardian-of-frost-7", "name": "Guardian of Frost 7", "rank": "emerald", "cost": 4, "kind": "unit", "hp": 847, "dmg": 53, "atkSpd": 0.95, "spd": 50, "range": 18, "archetype": "tank", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "sorcerer-of-the-deep-8", "name": "Sorcerer of the Deep 8", "rank": "emerald", "cost": 5, "kind": "unit", "hp": 466, "dmg": 65, "atkSpd": 0.85, "spd": 61, "range": 150, "archetype": "control", "curse": 0.25, "note": "Curses targets: they take 25% more damage for a short time."}, {"id": "duelist-of-frost-9", "name": "Duelist of Frost 9", "rank": "emerald", "cost": 7, "kind": "unit", "hp": 781, "dmg": 134, "atkSpd": 0.75, "spd": 91, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-the-deep-10", "name": "Squire of the Deep 10", "rank": "emerald", "cost": 6, "kind": "unit", "hp": 774, "dmg": 89, "atkSpd": 0.95, "spd": 63, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "silence-sigil-of-dawn-1", "name": "Silence Sigil of Dawn 1", "rank": "emerald", "cost": 4, "kind": "spell", "radius": 110, "silence": 2.04, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "time-stop-of-frost-2", "name": "Time Stop of Frost 2", "rank": "emerald", "cost": 7, "kind": "spell", "radius": 142, "freeze": 2.46, "note": "Freezes enemies briefly in a lane."}, {"id": "meteor-of-the-vale-3", "name": "Meteor of the Vale 3", "rank": "emerald", "cost": 6, "kind": "spell", "dmg": 619, "radius": 124, "stun": 0.92, "note": "Big AoE hit with a brief stun."}, {"id": "frost-mist-of-the-vale-4", "name": "Frost Mist of the Vale 4", "rank": "emerald", "cost": 7, "kind": "spell", "dmg": 199, "radius": 122, "slow": 0.55, "slowDur": 3.5, "note": "Damages and slows enemies."}, {"id": "time-stop-of-dawn-5", "name": "Time Stop of Dawn 5", "rank": "emerald", "cost": 5, "kind": "spell", "radius": 130, "freeze": 2.1, "note": "Freezes enemies briefly in a lane."}, {"id": "meteor-of-thorns-6", "name": "Meteor of Thorns 6", "rank": "emerald", "cost": 4, "kind": "spell", "dmg": 481, "radius": 112, "stun": 0.78, "note": "Big AoE hit with a brief stun."}, {"id": "meteor-of-ivory-7", "name": "Meteor of Ivory 7", "rank": "emerald", "cost": 7, "kind": "spell", "dmg": 688, "radius": 130, "stun": 0.99, "note": "Big AoE hit with a brief stun."}, {"id": "ranger-of-ivory-1", "name": "Ranger of Ivory 1", "rank": "ruby", "cost": 7, "kind": "unit", "hp": 724, "dmg": 96, "atkSpd": 0.8, "spd": 76, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "duelist-of-thorns-2", "name": "Duelist of Thorns 2", "rank": "ruby", "cost": 5, "kind": "unit", "hp": 654, "dmg": 114, "atkSpd": 0.75, "spd": 94, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "squire-of-ash-3", "name": "Squire of Ash 3", "rank": "ruby", "cost": 4, "kind": "unit", "hp": 625, "dmg": 73, "atkSpd": 0.95, "spd": 64, "range": 18, "archetype": "tankish", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-the-vale-4", "name": "Ranger of the Vale 4", "rank": "ruby", "cost": 5, "kind": "unit", "hp": 566, "dmg": 76, "atkSpd": 0.8, "spd": 72, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "sorcerer-of-ash-5", "name": "Sorcerer of Ash 5", "rank": "ruby", "cost": 6, "kind": "unit", "hp": 568, "dmg": 79, "atkSpd": 0.85, "spd": 68, "range": 150, "archetype": "control", "curse": 0.28, "note": "Curses targets: they take 28% more damage for a short time."}, {"id": "sorcerer-of-cinders-6", "name": "Sorcerer of Cinders 6", "rank": "ruby", "cost": 5, "kind": "unit", "hp": 498, "dmg": 70, "atkSpd": 0.85, "spd": 66, "range": 150, "archetype": "control", "curse": 0.25, "note": "Curses targets: they take 25% more damage for a short time."}, {"id": "duelist-of-cinders-7", "name": "Duelist of Cinders 7", "rank": "ruby", "cost": 7, "kind": "unit", "hp": 836, "dmg": 144, "atkSpd": 0.75, "spd": 98, "range": 18, "archetype": "assassin", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-ash-8", "name": "Ranger of Ash 8", "rank": "ruby", "cost": 6, "kind": "unit", "hp": 645, "dmg": 86, "atkSpd": 0.8, "spd": 74, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "skirmisher-of-shadow-9", "name": "Skirmisher of Shadow 9", "rank": "ruby", "cost": 7, "kind": "unit", "hp": 576, "dmg": 83, "atkSpd": 0.7, "spd": 101, "range": 18, "archetype": "swarm", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "ranger-of-iron-10", "name": "Ranger of Iron 10", "rank": "ruby", "cost": 5, "kind": "unit", "hp": 566, "dmg": 76, "atkSpd": 0.8, "spd": 72, "range": 140, "archetype": "ranged", "note": "Summon to a lane to push toward the enemy castle."}, {"id": "summon-imps-of-iron-1", "name": "Summon Imps of Iron 1", "rank": "ruby", "cost": 4, "kind": "spell", "summon": {"name": "Imp", "hp": 189, "dmg": 47, "atkSpd": 0.85, "spd": 115, "range": 16, "archetype": "swarm"}, "count": 3, "note": "Spawns 3 imps in the lane."}, {"id": "void-rift-of-thorns-2", "name": "Void Rift of Thorns 2", "rank": "ruby", "cost": 4, "kind": "spell", "dmg": 544, "radius": 112, "pull": 0.67, "note": "Pulls enemies inward and hits hard."}, {"id": "meteor-of-thorns-3", "name": "Meteor of Thorns 3", "rank": "ruby", "cost": 5, "kind": "spell", "dmg": 588, "radius": 118, "stun": 0.85, "note": "Big AoE hit with a brief stun."}, {"id": "void-rift-of-ivory-4", "name": "Void Rift of Ivory 4", "rank": "ruby", "cost": 4, "kind": "spell", "dmg": 544, "radius": 112, "pull": 0.67, "note": "Pulls enemies inward and hits hard."}, {"id": "summon-imps-of-ash-5", "name": "Summon Imps of Ash 5", "rank": "ruby", "cost": 6, "kind": "spell", "summon": {"name": "Imp", "hp": 233, "dmg": 62, "atkSpd": 0.85, "spd": 122, "range": 16, "archetype": "swarm"}, "count": 4, "note": "Spawns 4 imps in the lane."}, {"id": "silence-sigil-of-iron-6", "name": "Silence Sigil of Iron 6", "rank": "ruby", "cost": 7, "kind": "spell", "radius": 128, "silence": 2.52, "note": "Silences enemies (slows their attacks) briefly."}, {"id": "frost-mist-of-iron-7", "name": "Frost Mist of Iron 7", "rank": "ruby", "cost": 4, "kind": "spell", "dmg": 136, "radius": 104, "slow": 0.46, "slowDur": 3.0, "note": "Damages and slows enemies."}, {"id": "paladin", "name": "Paladin", "rank": "legendary", "cost": 6, "kind": "unit", "hp": 820, "dmg": 34, "atkSpd": 0.9, "spd": 34, "range": 18, "archetype": "tank", "auraHeal": 14, "shield": 180, "note": "Elite tank. Big HP, starts with a shield, and heals nearby allies."}, {"id": "warlock", "name": "Warlock", "rank": "legendary", "cost": 6, "kind": "unit", "hp": 480, "dmg": 30, "atkSpd": 0.78, "spd": 32, "range": 155, "archetype": "control", "curse": 0.28, "note": "Elite ranged control. Curses targets so they take 28% more damage briefly."}, {"id": "golem", "name": "Golem", "rank": "legendary", "cost": 7, "kind": "unit", "hp": 1100, "dmg": 42, "atkSpd": 1.05, "spd": 26, "range": 18, "archetype": "tank", "note": "Elite wall. Slow, but absurdly tanky."}, {"id": "dragon-breath", "name": "Dragon Breath", "rank": "legendary", "cost": 6, "kind": "spell", "dmg": 90, "radius": 165, "dot": 28, "dotDur": 3.2, "note": "Elite lane burn. Wide hit + strong burn over time."}, {"id": "chain-lightning", "name": "Chain Lightning", "rank": "legendary", "cost": 6, "kind": "spell", "dmg": 150, "jumps": 3, "radius": 42, "note": "Elite punishment spell. Bounces between 3 enemies."}, {"id": "phoenix", "name": "Phoenix", "rank": "mythic", "cost": 7, "kind": "unit", "hp": 520, "dmg": 44, "atkSpd": 0.78, "spd": 56, "range": 135, "archetype": "ranged", "revive": true, "multiShot": 2, "note": "Top-tier ranged carry. Multi-shot and revives once."}, {"id": "time-stop", "name": "Time Stop", "rank": "mythic", "cost": 7, "kind": "spell", "radius": 125, "freeze": 2.2, "note": "Freezes enemies in a lane for a long time â€” perfect for swings."}, {"id": "hydra", "name": "Hydra", "rank": "mythic", "cost": 8, "kind": "unit", "hp": 740, "dmg": 30, "atkSpd": 0.62, "spd": 38, "range": 150, "archetype": "ranged", "multiShot": 3, "note": "Three-headed barrage (3 targets). Melts clustered enemies."}, {"id": "celestial-knight", "name": "Celestial Knight", "rank": "secret", "cost": 8, "kind": "unit", "hp": 980, "dmg": 62, "atkSpd": 0.85, "spd": 42, "range": 22, "archetype": "tankish", "shield": 380, "revive": true, "auraHeal": 22, "note": "Best-in-game frontline. Huge shield, revives once, and heals nearby allies."}, {"id": "void-rift", "name": "Void Rift", "rank": "secret", "cost": 8, "kind": "spell", "dmg": 420, "radius": 110, "pull": 0.75, "stun": 1.0, "note": "Best-in-game spell. Massive damage, pulls enemies together, and stuns briefly."}];

  const WINS_TO_PROMOTE = {
    unranked: 5,
    bronze: 6,
    silver: 7,
    gold: 8,
    platinum: 10,
    diamond: 12,
    emerald: 14,
    ruby: 16,
    legendary: 20,
    mythic: 30,
    secret: 999999,
  };
  const SECRET_GATE = { mythicWins: 60, totalWins: 260, streak: 15 };
  function rankGainPct(rankId){
    // Gains get smaller at higher ranks (grindier).
    const map = { unranked: 20, bronze: 10, silver: 9, gold: 8, platinum: 7, diamond: 6, emerald: 5, ruby: 4, legendary: 3, mythic: 2, secret: 1 };
    return map[rankId] ?? 6;
  }

  function renderPracticeSetup(){
    normalizePracticeDeck();
    const rk = currentRank();
    const allowed = aiAllowedRanksSet();
    const pool = CARDS.filter(c=>allowed.has(c.rank)).sort((a,b)=> (a.cost-b.cost) || a.name.localeCompare(b.name));
    let query="";
    let showCustom = (save.practice.mode==="custom");

    const render = () => {
      const deck = save.practice.deck || [];
      const deckHtml = deck.map((id, idx)=>{
        const c=getCard(id);
        return `<div class="item">
          <div class="left">
            <div class="title">${idx+1}. <span class="chip">${portraitEmoji(c)}</span> ${c.name}</div>
            <div class="desc">${describeCard(c)}</div>
          </div>
          <div class="row">
            <span class="chip">ðŸ”® ${c.cost}</span>
            <div class="btn secondary" data-prm="${idx}" style="min-height:34px; padding:8px 10px;">Remove</div>
          </div>
        </div>`;
      }).join("");

      const listHtml = pool
        .filter(c => !query || c.name.toLowerCase().includes(query.toLowerCase()))
        .slice(0, 240)
        .map(c=>{
          const canAdd = showCustom && deck.length<10 && deck.filter(x=>x===c.id).length<2;
          return `<div class="item">
            <div class="left">
              <div class="title">
                <span class="chip">${portraitEmoji(c)}</span>
                <span class="${rarityClass(c.rank)}">${c.name}</span>
                <span class="chip">${c.kind.toUpperCase()}</span>
              </div>
              <div class="desc">${describeCard(c)}</div>
            </div>
            <div class="row">
              <span class="chip">ðŸ”® ${c.cost}</span>
              <div class="btn ${canAdd ? "" : "secondary"}" data-padd="${c.id}" style="min-height:34px; padding:8px 10px;">Add</div>
            </div>
          </div>`;
        }).join("");

      showModal(
        "Practice Setup",
        `
        <p>Practice matches give <b>no</b> rank %, gold, chests, or stats changes. Pick a meta bot, or build a custom bot deck using cards up to your current rank.</p>
        <div class="row">
          <span class="pill">Your Rank: <b class="${rarityClass(rk.id)}">${rk.name}</b></span>
          <span class="pill">Rank %: <b>${save.rankPct.toFixed(1)}%</b></span>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="btn ${save.practice.mode==="meta" ? "" : "secondary"}" id="pmMeta" style="min-height:40px">Meta Bot</div>
          <div class="btn ${save.practice.mode==="custom" ? "" : "secondary"}" id="pmCustom" style="min-height:40px">Custom Bot Deck</div>
        </div>

        ${
          save.practice.mode==="meta"
          ? `
            <div class="row" style="margin-top:10px">
              <span class="chip">Choose meta:</span>
              <div class="btn secondary" data-meta="Balanced" style="min-height:38px">Balanced</div>
              <div class="btn secondary" data-meta="Aggro" style="min-height:38px">Aggro</div>
              <div class="btn secondary" data-meta="Control" style="min-height:38px">Control</div>
              <div class="btn secondary" data-meta="Tank" style="min-height:38px">Tank</div>
              <div class="btn secondary" data-meta="Swarm" style="min-height:38px">Swarm</div>
            </div>
            <p class="small">Selected: <b>${save.practice.meta || "Balanced"}</b></p>
          `
          : `
            <div class="grid2" style="margin-top:10px">
              <div>
                <div class="small" style="margin:6px 0 8px">Bot Deck (10 cards, max 2 duplicates)</div>
                <div class="list">${deckHtml}</div>
              </div>
              <div>
                <div class="small" style="margin:6px 0 8px">Allowed Cards</div>
                <input class="search" id="pq" placeholder="Search cards..." value="${escapeHtml(query)}" />
                <div class="list" id="plist" style="margin-top:8px">${listHtml}</div>
              </div>
            </div>
          `
        }

        <div class="grid3" style="margin-top:12px">
          <div class="btn" id="pStart">Start Practice</div>
          <div class="btn secondary" id="pDeck">Your Deck</div>
          <div class="btn secondary" id="pClose">Close</div>
        </div>
        `,
        ``
      );

      document.getElementById("pClose").onclick = hideModal;
      document.getElementById("pDeck").onclick = () => renderDeckBuilder();
      document.getElementById("pStart").onclick = () => { hideModal(); startMatch('practice'); };

      document.getElementById("pmMeta").onclick = () => { save.practice.mode="meta"; persist(); render(); };
      document.getElementById("pmCustom").onclick = () => { save.practice.mode="custom"; persist(); render(); };

      els.modal.querySelectorAll("[data-meta]").forEach(b=>{
        b.onclick = () => { save.practice.meta = b.getAttribute("data-meta"); persist(); render(); };
      });

      const pq = document.getElementById("pq");
      if(pq) pq.oninput = (e)=>{ query=e.target.value; render(); };

      els.modal.querySelectorAll("[data-padd]").forEach(b=>{
        b.onclick = () => {
          if(save.practice.mode!=="custom") return;
          const id=b.getAttribute("data-padd");
          if(deck.length>=10) return;
          if(deck.filter(x=>x===id).length>=2) return;
          deck.push(id);
          save.practice.deck = deck;
          persist();
          render();
        };
      });
      els.modal.querySelectorAll("[data-prm]").forEach(b=>{
        b.onclick = () => {
          const idx=Number(b.getAttribute("data-prm"));
          deck.splice(idx,1);
          save.practice.deck = deck;
          normalizePracticeDeck();
          render();
        };
      });
    };
    render();
  }

  function rankLossPct(rankId){
    // Loss penalty increases at higher ranks. Bronze/Silver are tiny.
    const map = { unranked: 0, bronze: 1, silver: 1, gold: 2.5, platinum: 3.5, diamond: 4.5, emerald: 5.5, ruby: 6.5, legendary: 8, mythic: 10, secret: 12 };
    return map[rankId] ?? 4;
  }
  function clampRankPct(){ save.rankPct = Math.max(0, Math.min(99.9, save.rankPct)); }


  const SAVE_KEY = "crushlite_v4_save";
  const defaultSave = () => ({
    rankIndex: 0,
    rankPct: 0,
    mythicWins: 0,
    unlocked: {},
    gold: 0,
    streak: 0,
    bestStreak: 0,
    stats: { totalWins:0, totalLosses:0, chestsOpened:0 },
    cardLevel: {},
    chests: { common:0, rare:0, epic:0, legendary:0 },
    lastBot: { name:"", personality:"", deckName:"" },
    practice: { mode:"meta", meta:"Balanced", deck: [] },
    deck: [],
    playerArchetypeCounts: {swarm:0,tank:0,ranged:0,bruiser:0,control:0,assassin:0,antiTank:0,tankish:0},
  });

  let save = loadSave();
  ensureInitialUnlocks();
  ensureDeckValid();
  ensureLevels();

  function loadSave(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return defaultSave();
      const s = JSON.parse(raw);
      const d = defaultSave();
      for(const k in d) if(s[k]===undefined) s[k]=d[k];
      if(!s.unlocked) s.unlocked={};
      if(!s.cardLevel) s.cardLevel={};
      if(!s.chests) s.chests={common:0,rare:0,epic:0,legendary:0};
      if(!s.stats) s.stats={totalWins:0,totalLosses:0,chestsOpened:0};
      if(!Array.isArray(s.deck)) s.deck=[];
      if(!s.playerArchetypeCounts) s.playerArchetypeCounts=d.playerArchetypeCounts;
      if(typeof s.bestStreak!=="number") s.bestStreak=0;
      if(!s.lastBot) s.lastBot={name:"",personality:"",deckName:""};
      if(!s.practice) s.practice={mode:"meta", meta:"Balanced", deck: []};
      if(!Array.isArray(s.practice.deck)) s.practice.deck=[];
      if(typeof s.rankIndex!=="number") s.rankIndex=0;
      if(typeof s.rankPct!=="number") s.rankPct=0;
      if(typeof s.mythicWins!=="number") s.mythicWins=0;
      s.rankIndex = Math.max(0, Math.min(RANKS.length-1, s.rankIndex));
      return s;
    }catch(e){ return defaultSave(); }
  }
  function persist(){ localStorage.setItem(SAVE_KEY, JSON.stringify(save)); }

  function rankById(id){ return RANKS.find(r=>r.id===id); }
  function rankIndexOf(id){ return RANKS.findIndex(r=>r.id===id); }
  function getCard(id){ return CARDS.find(c=>c.id===id); }
  function unlockedCards(){ return CARDS.filter(c=>save.unlocked[c.id]); }
  function currentRank(){ return RANKS[save.rankIndex]; }
  function winsNeededForRank(rankId){ return (WINS_TO_PROMOTE[rankId] ?? 10); }

  function ensureInitialUnlocks(){
    for(const c of CARDS) if(c.rank==="unranked") save.unlocked[c.id]=true;
    persist();
  }
  function ensureLevels(){
    for(const c of CARDS) if(save.unlocked[c.id] && !save.cardLevel[c.id]) save.cardLevel[c.id]=1;
    persist();
  }
  function ensureDeckValid(){
    const pool = unlockedCards().map(c=>c.id);
    if(pool.length===0) return;
    save.deck = save.deck.filter(id => save.unlocked[id]);
    while(save.deck.length<10) save.deck.push(pool[Math.floor(Math.random()*pool.length)]);
    save.deck = save.deck.slice(0,10);
    persist();
  }

  function lvl(id){ return Math.max(1, Math.min(10, save.cardLevel[id] || 1)); }
  function mulByLevel(level){ return 1 + (level-1)*0.06; }
  function applyLevelToCard(baseCard){
    const c = JSON.parse(JSON.stringify(baseCard));
    const level = lvl(c.id);
    const m = mulByLevel(level);
    c.level = level;
    if(c.kind==="unit"){
      if(c.hp) c.hp = Math.round(c.hp*m);
      if(c.dmg) c.dmg = Math.round(c.dmg*m);
      if(c.shield) c.shield = Math.round(c.shield*m);
      if(c.auraHeal) c.auraHeal = Math.round(c.auraHeal*m);
    } else {
      if(c.dmg) c.dmg = Math.round(c.dmg*m);
      if(c.heal) c.heal = Math.round(c.heal*m);
      if(c.shieldAllies) c.shieldAllies = Math.round(c.shieldAllies*m);
      if(c.dot) c.dot = Math.round(c.dot*m);
    }
    return c;
  }

  // Upgrade screen
  function upgradeCost(cardId){
    const c = getCard(cardId);
    const rMul = 1 + rankIndexOf(c.rank)*0.22;
    const L = lvl(cardId);
    return Math.round((80 + L*60 + (L*L)*24) * rMul);
  }
  function upgradeCard(cardId){
    if(!save.unlocked[cardId]) return false;
    const L = lvl(cardId);
    if(L>=10) return false;
    const cost = upgradeCost(cardId);
    if(save.gold < cost) return false;
    save.gold -= cost;
    save.cardLevel[cardId] = L+1;
    persist();
    return true;
  }

  // Chests
  function chestRarityForWin(){
    const i = save.rankIndex;
    const roll = Math.random();
    const epicChance = Math.min(0.18, 0.05 + i*0.010);
    const legChance  = Math.min(0.05, 0.008 + i*0.0035);
    const rareChance = Math.min(0.34, 0.16 + i*0.013);
    if(roll < legChance) return "legendary";
    if(roll < legChance + epicChance) return "epic";
    if(roll < legChance + epicChance + rareChance) return "rare";
    return "common";
  }
  
  function unlockChanceMultiplier(){
    // Higher ranks unlock cards slower (grindier), lower ranks unlock faster.
    // 0: Unranked -> ~1.25x, then scales down toward ~0.45x.
    const m = 1.25 - save.rankIndex*0.08;
    return Math.max(0.45, Math.min(1.35, m));
  }
  function unlockAttemptsByRank(){
    // More unlock attempts early; fewer later.
    if(save.rankIndex <= 1) return 2;      // Unranked/Bronze
    if(save.rankIndex <= 3) return 2;      // Silver/Gold
    if(save.rankIndex <= 5) return 1;      // Platinum/Diamond
    return 1;                              // Emerald+
  }
function chestRewards(rarity){
    const i = save.rankIndex;
    const baseCoins = {common: 70, rare: 150, epic: 280, legendary: 480}[rarity] + i*14;
    const coins = Math.round(baseCoins * (0.90 + Math.random()*0.25));
    const levelUps = {common:1, rare:2, epic:3, legendary:5}[rarity];
    const unlockRoll = {common:0.55, rare:0.72, epic:0.86, legendary:0.96}[rarity];
    return {coins, levelUps, unlockRoll};
  }
  function aiAllowedRanksSet(){
    const allowed = new Set();
    for(let i=0;i<=save.rankIndex;i++) allowed.add(RANKS[i].id);
    return allowed;
  }
  function giveChestAfterWin(){
    const rarity = chestRarityForWin();
    save.chests[rarity] += 1;
    persist();
    return rarity;
  }
  function openChest(rarity){
    if(save.chests[rarity] <= 0) return null;
    save.chests[rarity] -= 1;
    save.stats.chestsOpened += 1;

    const rw = chestRewards(rarity);
    rw.unlockRoll = Math.max(0.05, Math.min(0.98, rw.unlockRoll * unlockChanceMultiplier()));
    save.gold += rw.coins;

    const results = [];
    results.push({type:"gold", amount: rw.coins});

    const allow = aiAllowedRanksSet();
    const lockedPool = CARDS.filter(c => allow.has(c.rank) && !save.unlocked[c.id]);

    // Multiple chances to unlock early-game (so you fill your collection faster at low ranks).
    const attempts = unlockAttemptsByRank();
    for(let a=0;a<attempts;a++){
      if(!lockedPool.length) break;
      if(Math.random() < rw.unlockRoll){
        const pick = lockedPool[Math.floor(Math.random()*lockedPool.length)];
        if(!save.unlocked[pick.id]){
          save.unlocked[pick.id] = true;
          save.cardLevel[pick.id] = 1;
          results.push({type:"unlock", cardId: pick.id});
        }
      }
    }

    const u = unlockedCards();
    for(let k=0;k<rw.levelUps;k++) {
      if(!u.length) break;
      const pick = u[Math.floor(Math.random()*u.length)];
      const cur = lvl(pick.id);
      if(cur < 10) {
        save.cardLevel[pick.id] = cur + 1;
        results.push({type:"level", cardId: pick.id, newLevel: cur+1});
      }
    }

    persist();
    return results;
  }

  // UI
  const els = {
    rankName: document.getElementById("rankName"),
    rankPct: document.getElementById("rankPct"),
    unlockedCount: document.getElementById("unlockedCount"),
    totalCards: document.getElementById("totalCards"),
    gold: document.getElementById("gold"),
    streak: document.getElementById("streak"),
    bestStreak: document.getElementById("bestStreak"),
    timeLeft: document.getElementById("timeLeft"),
    btnMenu: document.getElementById("btnMenu"),
    btnDeck: document.getElementById("btnDeck"),
    btnChests: document.getElementById("btnChests"),
    btnUpgrades: document.getElementById("btnUpgrades"),
    hand: document.getElementById("hand"),
    overlay: document.getElementById("overlay"),
    modal: document.getElementById("modal"),
    canvas: document.getElementById("canvas"),
  };
  function rarityClass(rank){ return "r-" + rank; }
  function updateTopbar(){
      // Promotion / demotion handling via rank %
      let promoted = false;

      // If we cross 100%, promote (carry over remainder).
      while(save.rankPct >= 100 && save.rankIndex < RANKS.length-1){
        const before = save.rankIndex;
        save.rankIndex += 1;
        save.rankPct -= 100;
        promoted = true;

        // Mythic â†’ Secret gate: only allow entry if requirements are met.
        const nowRank = currentRank();
        if(nowRank.id === "secret"){
          const ok = (save.mythicWins >= SECRET_GATE.mythicWins) && (save.stats.totalWins >= SECRET_GATE.totalWins) && (save.streak >= SECRET_GATE.streak);
          if(!ok){
            // Bounce back to mythic if gate not satisfied.
            save.rankIndex = before;
            save.rankPct = 99.0;
            promoted = false;
            break;
          }
        }
      }

      // Track mythic wins for secret gate
      if(currentRank().id === "mythic") save.mythicWins += 1;

      const promoUnlocked = grantPromotionRewards(prevRankIndex, save.rankIndex);
      persist(); ensureLevels(); ensureDeckValid(); updateTopbar();
 render();
        });
      });
      els.modal.querySelectorAll("[data-rm]").forEach(btn => {
        btn.addEventListener("click", () => {
          const idx=Number(btn.getAttribute("data-rm"));
          save.deck.splice(idx,1); persist(); render();
        });
      });
    };
    render();
  }

  // GAME CORE
  const ctx = els.canvas.getContext("2d");
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const GAME = {
    running:false,
    lanes:3,
    w:0,h:0,
    pCastle:{hp:1400,max:1400},
    aCastle:{hp:1400,max:1400},
    tMax:300, tLeft:300,
    pMana:3, pManaMax:10, pManaRegen:1.0,
    aMana:3, aManaMax:10, aManaRegen:1.0,
    pDeck:[], aDeck:[],
    pHand:[], aHand:[],
    selectedHandIndex:-1,
    units:[], effects:[],
    ai:{thinkCd:0, cadence:0.33, personality:"Balanced", deckName:"Meta Balanced"},
    mode:"ranked", // 'ranked' or 'practice'

  };

  function resize(){
    const rect = els.canvas.getBoundingClientRect();
    GAME.w = Math.floor(rect.width*DPR);
    GAME.h = Math.floor(rect.height*DPR);
    els.canvas.width = GAME.w;
    els.canvas.height = GAME.h;
  }
  window.addEventListener("resize", resize);

  function fmtTime(sec){ sec=Math.max(0,Math.floor(sec)); const m=Math.floor(sec/60); const s=sec%60; return `${m}:${String(s).padStart(2,"0")}`; }

  const BOT_NAMES = ["Vex","Eldra","Rook","Nyx","Kairo","Mira","Thorn","Lux","Sable","Orin"];
  function botPoolByRank(){
    const allowed = aiAllowedRanksSet();
    return CARDS.filter(c => allowed.has(c.rank));
  }

  function cardPower(base){
    if(base.kind==="unit"){
      let p=(base.hp||0) + (base.dmg||0)*14;
      if(base.shield) p += base.shield*0.8;
      if(base.revive) p += 320;
      if(base.multiShot) p += base.multiShot*180;
      if(base.auraHeal) p += base.auraHeal*60;
      if(base.bonusVs==="tank") p += 150;
      if(base.curse) p += base.curse*900;
      p *= (1 + rankIndexOf(base.rank)*0.06);
      return p / Math.max(2, base.cost);
    } else {
      let p=(base.dmg||0)*2.0 + (base.heal||0)*1.8 + (base.dot||0)*8.5;
      if(base.freeze) p += base.freeze*220;
      if(base.slow) p += 160;
      if(base.pull) p += 210;
      if(base.jumps) p += (base.jumps||0)*120;
      if(base.summon) p += 190;
      if(base.shieldAllies) p += base.shieldAllies*1.2;
      if(base.silence) p += (base.silence||0)*160;
      p *= (1 + rankIndexOf(base.rank)*0.06);
      return p / Math.max(2, base.cost);
    }
  }

  function buildMetaBotDeck(forcedPersonality){
    const pool = botPoolByRank();
    const personalities = [
      {name:"Aggro", deckName:"Meta Aggro", wantUnits:7, wantSpells:3, prefer:["assassin","bruiser","swarm"]},
      {name:"Control", deckName:"Meta Control", wantUnits:5, wantSpells:5, prefer:["control","ranged"]},
      {name:"Tank", deckName:"Meta Tank", wantUnits:7, wantSpells:3, prefer:["tank","tankish","antiTank"]},
      {name:"Swarm", deckName:"Meta Swarm", wantUnits:8, wantSpells:2, prefer:["swarm","assassin"]},
      {name:"Balanced", deckName:"Meta Balanced", wantUnits:6, wantSpells:4, prefer:["ranged","bruiser","tankish"]},
    ];
    const p = forcedPersonality ? (personalities.find(x=>x.name===forcedPersonality) || personalities[Math.floor(Math.random()*personalities.length)]) : personalities[Math.floor(Math.random()*personalities.length)];
    const name = BOT_NAMES[Math.floor(Math.random()*BOT_NAMES.length)];

    const top = Object.entries(save.playerArchetypeCounts||{}).sort((a,b)=>(b[1]||0)-(a[1]||0))[0]?.[0] || "";

    const scored = pool.map(c=>{
      let s = cardPower(c);
      const arch = (c.kind==="spell") ? "control" : (c.archetype||"bruiser");
      if(p.prefer.includes(arch)) s *= 1.18;
      if(top==="swarm" && c.kind==="spell" && (c.dot||c.dmg||c.jumps)) s *= 1.10;
      if(top==="tank" && (c.bonusVs==="tank" || (c.kind==="spell" && (c.pull||c.dmg)))) s *= 1.08;
      if(top==="ranged" && (c.kind==="spell" && (c.freeze||c.slow||c.pull))) s *= 1.07;
      s *= (0.92 + Math.random()*0.18);
      return {id:c.id, card:c, score:s};
    });

    const units = scored.filter(x=>x.card.kind==="unit").sort((a,b)=>b.score-a.score);
    const spells = scored.filter(x=>x.card.kind==="spell").sort((a,b)=>b.score-a.score);

    const deck=[];
    function addFrom(list){
      for(const x of list){
        if(deck.length>=10) return;
        if(deck.includes(x.id)) continue;
        deck.push(x.id); return;
      }
    }
    for(let i=0;i<p.wantUnits && deck.length<10;i++) addFrom(units);
    for(let i=0;i<p.wantSpells && deck.length<10;i++) addFrom(spells);

    const swing = spells.find(x => (x.card.freeze||0)>=2 || (x.card.dmg||0)>=250 || x.card.pull);
    if(swing && !deck.includes(swing.id)){
      const idx = deck.findIndex(id => (getCard(id)||{}).kind==="spell");
      if(idx>=0) deck[idx]=swing.id;
      else deck[deck.length-1]=swing.id;
    }
    const all = scored.sort((a,b)=>b.score-a.score);
    while(deck.length<10) addFrom(all);

    return {name, personality:p.name, deckName:p.deckName, deck};
  }

  function buildPracticeBotDeck(){
    // Build bot deck for practice based on saved.practice settings.
    const name = "Practice Bot";
    if(save.practice.mode === "custom" && save.practice.deck && save.practice.deck.length===10){
      return {name, personality:"Custom", deckName:"Custom Deck", deck:[...save.practice.deck]};
    }
    // Meta choice
    const forced = save.practice.meta || "Balanced";
    return buildMetaBotDeck(forced);
  }

  function validBotCardId(id){
    const c = getCard(id);
    if(!c) return false;
    const allow = aiAllowedRanksSet();
    return allow.has(c.rank);
  }

  function normalizePracticeDeck(){
    const allowIds = CARDS.filter(c=>aiAllowedRanksSet().has(c.rank)).map(c=>c.id);
    save.practice.deck = (save.practice.deck||[]).filter(id=>validBotCardId(id));
    while(save.practice.deck.length<10 && allowIds.length){
      save.practice.deck.push(allowIds[Math.floor(Math.random()*allowIds.length)]);
    }
    save.practice.deck = save.practice.deck.slice(0,10);
    persist();
  }

  function buildStartingHand(deck){ const hand=[]; for(let i=0;i<5;i++) drawCard(deck,hand); return hand; }
  function drawCard(deck, hand){ const id=deck.shift(); deck.push(id); hand.push(id); }

  function startMatch(mode='ranked'){
    resize();
    ensureDeckValid(); ensureLevels();
    GAME.mode = mode;
    GAME.running=true;
    GAME.tLeft=GAME.tMax;
    GAME.pCastle={hp:1400,max:1400};
    GAME.aCastle={hp:1400,max:1400};
    GAME.pMana=3; GAME.aMana=3;
    GAME.units=[]; GAME.effects=[];
    GAME.selectedHandIndex=-1;

    GAME.pDeck=[...save.deck];
    const bot = (mode==='practice') ? buildPracticeBotDeck() : buildMetaBotDeck();
    GAME.aDeck = bot.deck;
    GAME.ai.personality = bot.personality;
    GAME.ai.deckName = bot.deckName;
    save.lastBot = {name: bot.name, personality: bot.personality, deckName: bot.deckName};
    persist();

    GAME.pHand = buildStartingHand([...GAME.pDeck]);
    GAME.aHand = buildStartingHand([...GAME.aDeck]);

    GAME.ai.cadence = Math.max(0.18, 0.34 - save.rankIndex*0.018);
    GAME.ai.thinkCd = 0;

    renderHand();
    updateTopbar();
  }

  // Input
  function laneFromY(yPx){ const laneH=GAME.h/GAME.lanes; return Math.max(0, Math.min(GAME.lanes-1, Math.floor(yPx/laneH))); }
  function onTap(clientX, clientY){
    if(!GAME.running) return;
    const rect = els.canvas.getBoundingClientRect();
    const x=(clientX-rect.left)*DPR;
    const y=(clientY-rect.top)*DPR;
    const lane=laneFromY(y);

    if(GAME.selectedHandIndex<0){ ring(GAME.w/2, lane*(GAME.h/GAME.lanes)+(GAME.h/GAME.lanes)/2, 110*DPR, "warn"); return; }

    const id=GAME.pHand[GAME.selectedHandIndex];
    const base=getCard(id);
    const card=applyLevelToCard(base);
    if(GAME.pMana < card.cost){ floatText("Not enough mana!", x,y,"warn"); return; }

    GAME.pMana -= card.cost;
    playCard("p", card, lane);

    const arch = (base.kind==="spell") ? "control" : (base.archetype||"bruiser");
    if(save.playerArchetypeCounts[arch]!==undefined) save.playerArchetypeCounts[arch]+=1;
    persist();

    GAME.pHand.splice(GAME.selectedHandIndex,1);
    drawCard(GAME.pDeck, GAME.pHand);
    GAME.selectedHandIndex=-1;
    renderHand();
  }
  els.canvas.addEventListener("click", (e)=>onTap(e.clientX,e.clientY), {passive:true});
  els.canvas.addEventListener("touchstart", (e)=>{ const t=e.changedTouches[0]; if(t) onTap(t.clientX,t.clientY); }, {passive:true});

  // Combat
  function now(){ return performance.now()/1000; }
  function dist2(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy; }
  function playCard(side, card, lane){ if(card.kind==="unit") spawnUnit(side,lane,card); else castSpell(side,lane,card); }

  function spawnUnit(side,lane,card){
    const laneH=GAME.h/GAME.lanes;
    const y=lane*laneH+laneH/2;
    const x=(side==='p')?70*DPR:(GAME.w-70*DPR);
    const s = styleForCard(card.id);
    GAME.units.push({
      side,lane,x,y,
      cardId: card.id,
      style: s,
      maxHp:card.hp, hp:card.hp,
      shield:card.shield||0,
      dmg:card.dmg,
      atkSpd:card.atkSpd||0.9,
      atkCd:0,
      spd:(card.spd||40)*DPR,
      range:(card.range||18)*DPR,
      isRanged:(card.range||0)>=80,
      revive:!!card.revive, revived:false,
      multiShot:card.multiShot||1,
      curse:card.curse||0,
      auraHeal:card.auraHeal||0,
      bonusVs:card.bonusVs||null,
      bonusMul:card.bonusMul||1.0,
      slowMul:1.0
    });
    puff(x,y, side==='p'?"good":"bad");
  }

  function castSpell(side,lane,spell){
    const midX=GAME.w/2;
    const laneH=GAME.h/GAME.lanes;
    const y=lane*laneH+laneH/2;
    spellBurst(midX,y, spell.id, side==='p'?"good":"bad", 1.0);
    const rad=(spell.radius||90)*DPR;

    const enemies=GAME.units.filter(u=>u.lane===lane && u.side!==side);
    const allies=GAME.units.filter(u=>u.lane===lane && u.side===side);

    if(spell.summon){
      const count=spell.count||1;
      for(let i=0;i<count;i++) spawnUnit(side,lane, {
        id: spell.id + "_summon_"+i,
        name:(spell.summon.name||"Imp"),
        hp:spell.summon.hp, dmg:spell.summon.dmg,
        atkSpd:spell.summon.atkSpd||0.85,
        spd:spell.summon.spd||60,
        range:spell.summon.range||16,
        archetype:spell.summon.archetype||"swarm",
        shield:0
      });
    }

    if(spell.shieldAllies){
      for(const a of allies) if(dist2(a.x,a.y,midX,y)<=rad*rad) a.shield=(a.shield||0)+spell.shieldAllies;
      floatText("+Shield", midX,y,"good");
    }
    if(spell.heal){
      for(const a of allies) if(dist2(a.x,a.y,midX,y)<=rad*rad) a.hp=Math.min(a.maxHp,a.hp+spell.heal);
      floatText(`+${spell.heal}`, midX,y,"good");
    }

    if(spell.jumps){
      let pool=[...enemies];
      let fromX=midX, fromY=y;
      let jumps=spell.jumps;
      while(jumps>0 && pool.length){
        pool.sort((a,b)=>dist2(a.x,a.y,fromX,fromY)-dist2(b.x,b.y,fromX,fromY));
        const t=pool.shift();
        dealDamage(t, spell.dmg||0);
        bolt(fromX,fromY,t.x,t.y, side==='p'?"good":"bad");
        fromX=t.x; fromY=t.y;
        jumps--;
      }
      return;
    }

    for(const u of enemies){
      if(dist2(u.x,u.y,midX,y)>rad*rad) continue;
      if(spell.dmg) dealDamage(u, spell.dmg);
      if(spell.stun) u.stunUntil=now()+spell.stun;
      if(spell.slow) { u.slowMul=Math.max(0.30,1.0-spell.slow); u.slowUntil=now()+(spell.slowDur||2.5); }
      if(spell.freeze) u.freezeUntil=now()+spell.freeze;
      if(spell.pull) u.pull={x:midX,y:y,mul:spell.pull,until:now()+0.7};
      if(spell.dot) u.dot={dps:spell.dot,until:now()+(spell.dotDur||3.0)};
      if(spell.silence) u.silenceUntil=now()+spell.silence;
    }
  }

  function dealDamage(u, amount){
    let dmg=amount;
    if(u.dmgTakenMul) dmg*=u.dmgTakenMul;
    if(u.shield && u.shield>0){
      const s=Math.min(u.shield,dmg);
      u.shield-=s; dmg-=s;
    }
    u.hp-=dmg;
    hit(u.x,u.y);
  }

  function updateUnits(dt){
    for(const u of GAME.units){
      if(u.auraHeal){
        const allies=GAME.units.filter(v=>v.side===u.side && v.lane===u.lane);
        for(const a of allies){
          if(a===u) continue;
          if(Math.abs(a.x-u.x)<=120*DPR) a.hp=Math.min(a.maxHp,a.hp+u.auraHeal*dt);
        }
      }
    }

    for(const u of GAME.units){
      if(u.dot && now()<u.dot.until) u.hp -= (u.dot.dps*dt);
      if(u.slowUntil && now()>u.slowUntil){u.slowMul=1.0; u.slowUntil=0;}
      const slowMul=u.slowMul||1.0;
      const silenced=(u.silenceUntil && now()<u.silenceUntil);

      if(u.freezeUntil && now()<u.freezeUntil) continue;
      if(u.stunUntil && now()<u.stunUntil) continue;

      if(u.pull && now()<u.pull.until){
        u.x += (u.pull.x-u.x)*(u.pull.mul*dt);
        u.y += (u.pull.y-u.y)*(u.pull.mul*dt);
      }

      const dir=(u.side==='p')?1:-1;
      const targets=GAME.units.filter(v=>v.lane===u.lane && v.side!==u.side);

      let target=null, bestD=Infinity;
      for(const t of targets){
        const d=Math.abs(t.x-u.x);
        if(d<bestD){bestD=d; target=t;}
      }

      const castleX=(u.side==='p')?(GAME.w-90*DPR):(90*DPR);
      const distToCastle=Math.abs(castleX-u.x);

      u.atkCd -= dt;
      const atkSpeedMul = silenced ? 1.45 : 1.0;

      if(target && bestD<=u.range){
        if(u.atkCd<=0){
          u.atkCd = u.atkSpd*atkSpeedMul;
          const close=targets.sort((a,b)=>Math.abs(a.x-u.x)-Math.abs(b.x-u.x)).slice(0,u.multiShot);
          for(const t of close){
            let d=u.dmg;
            if(u.bonusVs==="tank" && t.maxHp>=520) d*=u.bonusMul;
            if(u.curse){ t.dmgTakenMul=1.0+u.curse; t.curseUntil=now()+2.6; }
            dealDamage(t,d);
            attackFx(u, t);
          }
        }
      } else if(distToCastle<=u.range){
        if(u.atkCd<=0){
          u.atkCd = u.atkSpd*atkSpeedMul;
          if(u.side==='p') GAME.aCastle.hp -= u.dmg;
          else GAME.pCastle.hp -= u.dmg;
          ring(castleX,u.y,26*DPR, u.side==='p'?"good":"bad");
          spellBurst(castleX,u.y,"castle_hit_"+u.cardId, u.side==='p'?"good":"bad", 0.6);
        }
      } else {
        u.x += (u.spd*slowMul*dt)*dir;
      }

      if(u.curseUntil && now()>u.curseUntil){u.dmgTakenMul=1.0; u.curseUntil=0;}
    }

    for(let i=GAME.units.length-1;i>=0;i--){
      const u=GAME.units[i];
      if(u.hp<=0){
        if(u.revive && !u.revived){
          u.revived=true;
          u.hp=u.maxHp*0.4;
          puff(u.x,u.y,"warn");
          floatText("REVIVE!",u.x,u.y,"warn");
        } else {
          GAME.units.splice(i,1);
        }
      }
    }
  }

  // AI
  function aiThink(dt){
    GAME.ai.thinkCd -= dt;
    if(GAME.ai.thinkCd>0) return;
    GAME.ai.thinkCd = GAME.ai.cadence;

    const smarts=Math.min(1.0,0.28+save.rankIndex*0.08);
    const playable=GAME.aHand.map((id,idx)=>({id,idx,card:getCard(id)})).filter(o=>o.card && o.card.cost<=GAME.aMana);
    if(!playable.length) return;

    const laneScores=[];
    for(let lane=0; lane<GAME.lanes; lane++){
      const enemies=GAME.units.filter(u=>u.lane===lane && u.side==='p');
      const allies=GAME.units.filter(u=>u.lane===lane && u.side==='a');
      const enemyPower=enemies.reduce((s,u)=>s+(u.hp/70+u.dmg*0.9),0);
      const allyPower=allies.reduce((s,u)=>s+(u.hp/70+u.dmg*0.9),0);
      const closeThreat=enemies.reduce((m,u)=>Math.max(m,u.x/GAME.w),0);
      laneScores.push({lane, enemyPower, allyPower, closeThreat, enemies: enemies.length});
    }
    laneScores.sort((a,b)=>(b.closeThreat*10+b.enemyPower)-(a.closeThreat*10+a.enemyPower));
    const defendLane=laneScores[0].lane;
    laneScores.sort((a,b)=>((b.allyPower-b.enemyPower)-(a.allyPower-a.enemyPower)));
    const attackLane=laneScores[0].lane;

    const underThreat = laneScores.find(x=>x.lane===defendLane).closeThreat > (0.60 - smarts*0.10);
    const lane = underThreat ? defendLane : attackLane;

    const spellOptions=playable.filter(o=>o.card.kind==="spell");
    const unitOptions=playable.filter(o=>o.card.kind==="unit");

    const p = GAME.ai.personality;
    const preferSpells = (p==="Control") ? 0.66 : (p==="Balanced" ? 0.45 : 0.25);

    let choice=null;
    if(spellOptions.length && (Math.random()<preferSpells) && (laneScores.find(x=>x.lane===lane).enemies >= (smarts>0.7?2:3) || underThreat)) {
      choice = pickBestSpell(spellOptions, lane, smarts);
    }
    if(!choice){
      unitOptions.sort((a,b)=>scoreUnit(b.card,lane,smarts)-scoreUnit(a.card,lane,smarts));
      choice = unitOptions[0] || spellOptions[0];
    }
    if(!choice) return;

    GAME.aMana -= choice.card.cost;
    playCard("a", choice.card, lane);

    GAME.aHand.splice(choice.idx,1);
    drawCard(GAME.aDeck, GAME.aHand);
  }

  function pickBestSpell(opts,lane,smarts){
    const enemies=GAME.units.filter(u=>u.lane===lane && u.side==='p');
    const allies=GAME.units.filter(u=>u.lane===lane && u.side==='a');
    function val(sp){
      let v=0;
      if(sp.dmg) v+=sp.dmg*0.20+enemies.length*14;
      if(sp.pull) v+=42+enemies.length*12;
      if(sp.freeze) v+=36+enemies.length*10;
      if(sp.slow) v+=22+enemies.length*8;
      if(sp.heal) {
        const miss=allies.reduce((s,u)=>s+(u.maxHp-u.hp),0);
        v += miss*0.10;
      }
      if(sp.dot) v+=18+enemies.length*6;
      if(sp.jumps) v+=28+enemies.length*9;
      if(sp.summon) v+=24;
      if(sp.shieldAllies) v+=16;
      if(sp.silence) v+=20;
      v *= (0.85+smarts*0.35);
      return v;
    }
    const scored=opts.map(o=>({o, v:val(o.card)})).sort((a,b)=>b.v-a.v);
    return (Math.random()<0.14 && scored[1]) ? scored[1].o : scored[0].o;
  }
  function scoreUnit(c,lane,smarts){
    const enemies=GAME.units.filter(u=>u.lane===lane && u.side==='p');
    const enemyRanged=enemies.filter(u=>u.isRanged).length;
    let v=c.hp*0.05 + c.dmg*0.9 - c.cost*5;
    if((c.range||0)>=80 && (enemies.length-enemyRanged)>enemyRanged) v+=18;
    if((c.archetype||"")==="assassin" && enemyRanged>=1) v+=22;
    if(c.bonusVs==="tank" && enemies.some(u=>u.maxHp>=520)) v+=24;
    v += rankIndexOf(c.rank)*(smarts*2.0);
    v *= (0.9+Math.random()*0.2);
    return v;
  }

  // FX
  function ring(x,y,r,tone){ GAME.effects.push({t:now(),kind:"ring",x,y,r,tone}); }
  function puff(x,y,tone){ GAME.effects.push({t:now(),kind:"puff",x,y,tone}); }
  function bolt(x1,y1,x2,y2,tone){ GAME.effects.push({t:now(),kind:"bolt",x1,y1,x2,y2,tone}); }
  function hit(x,y){ GAME.effects.push({t:now(),kind:"hit",x,y}); }
  function floatText(text,x,y,tone){ GAME.effects.push({t:now(),kind:"text",text,x,y,tone}); }
  function spellBurst(x,y,seed,tone,scale){ GAME.effects.push({t:now(),kind:"burst",x,y,seed,tone,scale}); }
  function attackFx(att, tgt){
    const s = att.style || styleForCard(att.cardId||"x");
    if(att.isRanged) bolt(att.x,att.y,tgt.x,tgt.y, att.side==='p'?"good":"bad");
    else GAME.effects.push({t:now(),kind:"slash",x1:att.x,y1:att.y,x2:tgt.x,y2:tgt.y,hue:s.hue});
  }

  // Render
  function draw(){
    const w=GAME.w, h=GAME.h;
    ctx.clearRect(0,0,w,h);

    const laneH=h/GAME.lanes;
    for(let i=0;i<GAME.lanes;i++){
      const y=i*laneH;
      ctx.fillStyle=(i%2===0)?"rgba(255,255,255,0.030)":"rgba(255,255,255,0.020)";
      ctx.fillRect(0,y,w,laneH);
      ctx.strokeStyle="rgba(255,255,255,0.10)";
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    ctx.setLineDash([7*DPR,7*DPR]);
    ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke();
    ctx.setLineDash([]);

    drawCastle(90*DPR,h/2,GAME.pCastle,true);
    drawCastle(w-90*DPR,h/2,GAME.aCastle,false);

    for(const u of GAME.units) drawUnit(u);
    drawEffects();
    drawHUD();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function drawCastle(x,y,castle,isPlayerLeft){
    const bw=62*DPR, bh=130*DPR;
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle=isPlayerLeft?"rgba(88,255,155,0.11)":"rgba(255,92,122,0.11)";
    ctx.strokeStyle=isPlayerLeft?"rgba(88,255,155,0.38)":"rgba(255,92,122,0.38)";
    ctx.lineWidth=2*DPR;
    roundRect(-bw/2,-bh/2,bw,bh,12*DPR,true,true);

    const barW=92*DPR, barH=10*DPR;
    const p=Math.max(0,Math.min(1,castle.hp/castle.max));
    ctx.fillStyle="rgba(255,255,255,0.10)";
    roundRect(-barW/2,-bh/2-20*DPR,barW,barH,999*DPR,true,false);
    ctx.fillStyle=isPlayerLeft?"rgba(88,255,155,0.88)":"rgba(255,92,122,0.88)";
    roundRect(-barW/2,-bh/2-20*DPR,barW*p,barH,999*DPR,true,false);

    ctx.fillStyle="rgba(236,242,255,0.92)";
    ctx.font=`${14*DPR}px system-ui`;
    ctx.textAlign="center";
    ctx.fillText(Math.max(0,Math.floor(castle.hp)),0,-bh/2-28*DPR);
    ctx.restore();

    // Mode label
    ctx.fillStyle="rgba(236,242,255,0.62)";
    ctx.font=`${11*DPR}px system-ui`;
    ctx.textAlign="left";
    ctx.fillText(GAME.mode==='practice' ? 'Practice (no rewards)' : 'Ranked', 14*DPR, 56*DPR);
  }

  function drawPoly(x,y,r,n,rot){
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a = rot + i*(Math.PI*2/n);
      const px = x + Math.cos(a)*r;
      const py = y + Math.sin(a)*r;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
  }

  function drawUnit(u){
    const isP=u.side==='p';
    const baseR = (u.maxHp>=900)?22*DPR:(u.maxHp>=600?18*DPR:14*DPR);
    const s = u.style || styleForCard(u.cardId||"x");
    const glow = isP ? "rgba(88,255,155,0.18)" : "rgba(255,92,122,0.18)";
    const outline = isP ? "rgba(88,255,155,0.70)" : "rgba(255,92,122,0.70)";
    const fill = `hsla(${s.hue}, 80%, 55%, 0.22)`;
    const stroke = `hsla(${s.hue2}, 90%, 70%, 0.75)`;

    ctx.beginPath();
    ctx.fillStyle = glow;
    ctx.arc(u.x,u.y,baseR+12*DPR,0,Math.PI*2); ctx.fill();

    ctx.save();
    ctx.lineWidth=2*DPR;
    ctx.fillStyle = fill;
    ctx.strokeStyle = outline;

    if(s.shape==="circle"){
      ctx.beginPath(); ctx.arc(u.x,u.y,baseR,0,Math.PI*2); ctx.fill(); ctx.stroke();
    } else if(s.shape==="diamond"){
      drawPoly(u.x,u.y,baseR,4,Math.PI/4); ctx.fill(); ctx.stroke();
    } else if(s.shape==="hex"){
      drawPoly(u.x,u.y,baseR,6,Math.PI/6); ctx.fill(); ctx.stroke();
    } else if(s.shape==="tri"){
      drawPoly(u.x,u.y,baseR,3,-Math.PI/2); ctx.fill(); ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.rect(u.x-baseR,u.y-baseR,baseR*2,baseR*2);
      ctx.fill(); ctx.stroke();
    }

    ctx.strokeStyle = stroke;
    ctx.globalAlpha = 0.65;
    ctx.beginPath(); ctx.arc(u.x,u.y,baseR*0.55,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1.0;

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.5*DPR;
    if(u.isRanged){
      ctx.beginPath(); ctx.arc(u.x+baseR*0.55,u.y,baseR*0.60, -Math.PI/2, Math.PI/2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.moveTo(u.x-baseR*0.2,u.y+baseR*0.8); ctx.lineTo(u.x+baseR*0.7,u.y-baseR*0.6); ctx.stroke();
    }

    if(u.shield && u.shield>0){
      ctx.beginPath();
      ctx.strokeStyle="rgba(122,168,255,0.70)";
      ctx.lineWidth=2*DPR;
      ctx.arc(u.x,u.y,baseR+5*DPR,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    const barW=48*DPR, barH=6.5*DPR;
    const yy=u.y-baseR-15*DPR;
    ctx.fillStyle="rgba(255,255,255,0.10)";
    roundRect(u.x-barW/2,yy,barW,barH,999*DPR,true,false);
    const p=Math.max(0,Math.min(1,u.hp/u.maxHp));
    ctx.fillStyle=isP?"rgba(88,255,155,0.90)":"rgba(255,92,122,0.90)";
    roundRect(u.x-barW/2,yy,barW*p,barH,999*DPR,true,false);
  }

  function drawEffects(){
    const t=now();
    const keep=[];
    for(const e of GAME.effects){
      const age=t-e.t;
      if(e.kind==="ring"){
        if(age>0.55) continue;
        const a=1-age/0.55;
        ctx.beginPath();
        ctx.strokeStyle = e.tone==="good" ? `rgba(88,255,155,${0.60*a})` :
                         e.tone==="bad"  ? `rgba(255,92,122,${0.60*a})` :
                         `rgba(255,209,92,${0.60*a})`;
        ctx.lineWidth=3*DPR;
        ctx.arc(e.x,e.y,e.r+age*35*DPR,0,Math.PI*2); ctx.stroke();
        keep.push(e);
      } else if(e.kind==="puff"){
        if(age>0.45) continue;
        const a=1-age/0.45;
        ctx.beginPath();
        ctx.fillStyle = e.tone==="good" ? `rgba(88,255,155,${0.20*a})` :
                        e.tone==="bad"  ? `rgba(255,92,122,${0.20*a})` :
                        `rgba(255,209,92,${0.20*a})`;
        ctx.arc(e.x,e.y,(18+age*42)*DPR,0,Math.PI*2); ctx.fill();
        keep.push(e);
      } else if(e.kind==="bolt"){
        if(age>0.20) continue;
        const a=1-age/0.20;
        ctx.strokeStyle = e.tone==="good" ? `rgba(88,255,155,${0.75*a})` : `rgba(255,92,122,${0.75*a})`;
        ctx.lineWidth=2.5*DPR;
        ctx.beginPath(); ctx.moveTo(e.x1,e.y1); ctx.lineTo(e.x2,e.y2); ctx.stroke();
        keep.push(e);
      } else if(e.kind==="slash"){
        if(age>0.22) continue;
        const a=1-age/0.22;
        ctx.strokeStyle = `hsla(${e.hue}, 95%, 70%, ${0.85*a})`;
        ctx.lineWidth=3*DPR;
        ctx.beginPath();
        ctx.moveTo(e.x1, e.y1);
        ctx.quadraticCurveTo((e.x1+e.x2)/2, (e.y1+e.y2)/2 - 25*DPR, e.x2, e.y2);
        ctx.stroke();
        keep.push(e);
      } else if(e.kind==="hit"){
        if(age>0.28) continue;
        const a=1-age/0.28;
        ctx.beginPath();
        ctx.fillStyle=`rgba(255,255,255,${0.50*a})`;
        ctx.arc(e.x,e.y,(6+age*22)*DPR,0,Math.PI*2); ctx.fill();
        keep.push(e);
      } else if(e.kind==="burst"){
        if(age>0.55) continue;
        const a=1-age/0.55;
        const h = hash32(e.seed||"seed");
        const hue = (h%360);
        const N = 10 + (h%8);
        for(let i=0;i<N;i++){
          const ang = (i/N)*Math.PI*2 + (h%100)/100;
          const rr = (18 + age*70) * DPR * (e.scale||1);
          const px = e.x + Math.cos(ang)*rr;
          const py = e.y + Math.sin(ang)*rr;
          ctx.fillStyle = `hsla(${hue}, 90%, 65%, ${0.22*a})`;
          ctx.beginPath(); ctx.arc(px,py,(4+((h>>i)%4))*DPR,0,Math.PI*2); ctx.fill();
        }
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${hue}, 90%, 70%, ${0.45*a})`;
        ctx.lineWidth = 2.5*DPR;
        ctx.arc(e.x,e.y,(22+age*28)*DPR*(e.scale||1),0,Math.PI*2);
        ctx.stroke();
        keep.push(e);
      } else if(e.kind==="text"){
        if(age>0.95) continue;
        const a=1-age/0.95;
        ctx.fillStyle =
          e.tone==="good" ? `rgba(88,255,155,${0.95*a})` :
          e.tone==="warn" ? `rgba(255,209,92,${0.95*a})` :
          `rgba(255,92,122,${0.95*a})`;
        ctx.font=`${14*DPR}px system-ui`;
        ctx.textAlign="center";
        ctx.fillText(e.text, e.x, e.y - age*30*DPR);
        keep.push(e);
      }
    }
    GAME.effects=keep;
  }

  function drawHUD(){
    ctx.fillStyle="rgba(236,242,255,0.80)";
    ctx.font=`${12*DPR}px system-ui`;
    ctx.textAlign="right";
    ctx.fillText(`â³ ${fmtTime(GAME.tLeft)}`, GAME.w-12*DPR, 18*DPR);

    ctx.save();
    ctx.translate(14*DPR, 18*DPR);
    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.lineWidth=1*DPR;
    roundRect(0,0, 210*DPR, 26*DPR, 12*DPR, true, true);
    ctx.fillStyle="rgba(236,242,255,0.86)";
    ctx.textAlign="left";
    ctx.fillText(`ðŸ”® ${GAME.pMana.toFixed(1)}/${GAME.pManaMax}`, 10*DPR, 18*DPR);
    const barW=90*DPR, barH=8*DPR;
    ctx.fillStyle="rgba(255,255,255,0.10)";
    roundRect(120*DPR, 9*DPR, barW, barH, 999*DPR, true, false);
    ctx.fillStyle="rgba(122,168,255,0.90)";
    const p = Math.max(0, Math.min(1, GAME.pMana/GAME.pManaMax));
    roundRect(120*DPR, 9*DPR, barW*p, barH, 999*DPR, true, false);
    ctx.restore();

    // Mode label
    ctx.fillStyle="rgba(236,242,255,0.62)";
    ctx.font=`${11*DPR}px system-ui`;
    ctx.textAlign="left";
    ctx.fillText(GAME.mode==='practice' ? 'Practice (no rewards)' : 'Ranked', 14*DPR, 56*DPR);
  }

  function renderHand(){
    els.hand.innerHTML="";
    for(let i=0;i<GAME.pHand.length;i++){
      const base=getCard(GAME.pHand[i]);
      const c=applyLevelToCard(base);
      const canPlay = GAME.pMana >= c.cost;
      const div=document.createElement("div");
      div.className="card"+(i===GAME.selectedHandIndex?" sel":"")+(!canPlay?" disabled":"");
      const emoji = portraitEmoji(base);
      div.innerHTML = `
        <div class="row1">
          <div style="display:flex; gap:8px; align-items:flex-start;">
            <div class="portrait">${emoji}</div>
            <div>
              <div class="name">${c.name}</div>
              <div class="sub"><span class="${rarityClass(c.rank)}">${rankById(c.rank).name}</span> Â· ${c.kind.toUpperCase()}</div>
            </div>
          </div>
          <div style="display:flex; gap:6px;">
            <div class="badge lvl">Lv ${c.level}</div>
            <div class="badge mana">ðŸ”® ${c.cost}</div>
          </div>
        </div>
        <div class="sub" style="margin-top:8px">${describeCard(c)}</div>
      `;
      div.addEventListener("click", ()=>{ if(!GAME.running) return; GAME.selectedHandIndex=(GAME.selectedHandIndex===i)?-1:i; renderHand(); });
      els.hand.appendChild(div);
    }
  }

  let last=performance.now();
  function tick(ts){
    const dt=Math.min(0.033,(ts-last)/1000);
    last=ts;

    if(GAME.running){
      GAME.tLeft -= dt;
      els.timeLeft.textContent = fmtTime(GAME.tLeft);
      GAME.pMana = Math.min(GAME.pManaMax, GAME.pMana + GAME.pManaRegen*dt);
      GAME.aMana = Math.min(GAME.aManaMax, GAME.aMana + GAME.aManaRegen*dt);

      aiThink(dt);
      updateUnits(dt);

      if(GAME.pCastle.hp<=0 || GAME.aCastle.hp<=0 || GAME.tLeft<=0) endMatch();
      if((ts|0)%120===0) renderHand();
    }

    draw();
    requestAnimationFrame(tick);
  }

  
  function promotionUnlockCount(nextRankId){
    // Big unlocks early, smaller later.
    const map = { bronze:6, silver:5, gold:4, platinum:3, diamond:3, emerald:2, ruby:2, legendary:1, mythic:1, secret:0 };
    return map[nextRankId] ?? 0;
  }
  function grantPromotionRewards(prevIndex, newIndex){
    if(newIndex<=prevIndex) return [];
    const unlockedNow = [];
    const newRank = RANKS[newIndex];
    const count = promotionUnlockCount(newRank.id);
    if(count<=0) return unlockedNow;

    const pool = CARDS.filter(c => c.rank === newRank.id && !save.unlocked[c.id]);
    for(let i=0;i<count && pool.length;i++){
      const k = Math.floor(Math.random()*pool.length);
      const pick = pool.splice(k,1)[0];
      save.unlocked[pick.id] = true;
      save.cardLevel[pick.id] = 1;
      unlockedNow.push(pick.id);
    }
    // Small gold reward
    save.gold += Math.round(120 + newIndex*35);
    return unlockedNow;
  }
function endMatch(){
    if(!GAME.running) return;
    GAME.running=false;

    const pHP=GAME.pCastle.hp, aHP=GAME.aCastle.hp;
    const win = (aHP<=0) || (pHP>aHP && GAME.tLeft<=0);

    if(GAME.mode==='practice'){
      // Practice: no rewards, no rank changes, no stats changes.
      showModal(
        win ? "Practice Win âœ…" : "Practice Loss âŒ",
        `
        <p>No rewards or penalties in practice.</p>
        <div class="row">
          <span class="pill">Bot: <b>${save.lastBot.name}</b> Â· <b>${save.lastBot.personality}</b></span>
          <span class="pill">Rank remains: <b>${currentRank().name}</b> Â· <b>${save.rankPct.toFixed(1)}%</b></span>
        </div>
        <div class="grid3" style="margin-top:10px">
          <div class="btn" id="pRematch">Practice Again</div>
          <div class="btn secondary" id="pSetup">Practice Setup</div>
          <div class="btn secondary" id="pHome">Home</div>
        </div>
        `,
        ``
      );
      document.getElementById("pRematch").onclick = () => { hideModal(); startMatch('practice'); };
      document.getElementById("pSetup").onclick = () => { renderPracticeSetup(); };
      document.getElementById("pHome").onclick = () => { hideModal(); renderHome(); };
      return;
    }

    if(win){
      const prevRankIndex = save.rankIndex;
      save.stats.totalWins += 1;
      save.rankPct += 1;
      save.streak += 1;
      save.bestStreak = Math.max(save.bestStreak, save.streak);

      // Ranked % gain
      const rkNow = currentRank();
      save.rankPct += rankGainPct(rkNow.id);

      const chest = giveChestAfterWin();

      const rk = currentRank();
      const need = winsNeededForRank(rk.id);

      if(rk.id==="mythic"){
        if(save.rankPct >= SECRET_GATE.mythicWins && save.stats.totalWins >= SECRET_GATE.totalWins && save.streak >= SECRET_GATE.streak){
          save.rankIndex = Math.min(RANKS.length-1, save.rankIndex+1);
          save.rankPct = 0;
        }
      } else if(save.rankPct >= need && save.rankIndex < RANKS.length-1){
        save.rankIndex += 1;
        save.rankPct = 0;
      }

      const promoUnlocked = grantPromotionRewards(prevRankIndex, save.rankIndex);
      persist(); ensureLevels(); ensureDeckValid(); updateTopbar();

      showModal(
        "Victory! ðŸ†",
        `
        <p>You earned a <b>${chest}</b> chest.</p>
        ${promoUnlocked && promoUnlocked.length ? `<p><b>Promotion reward:</b> unlocked ${promoUnlocked.length} card(s) from <b>${currentRank().name}</b>.</p>` : ``}
        <div class="row">
          <span class="pill good">WIN</span>
          <span class="pill">Bot: <b>${save.lastBot.name}</b> Â· <b>${save.lastBot.personality}</b></span>
          <span class="pill">Streak: <b>${save.streak}</b> (Best <b>${save.bestStreak}</b>)</span>
          <span class="pill">Rank %: <b>${save.rankPct.toFixed(1)}%</b></span>
          <span class="pill">Rank %: <b>${save.rankPct.toFixed(1)}%</b></span>
        </div>
        <div class="grid3" style="margin-top:10px">
          <div class="btn" id="openNow">Open Chests</div>
          <div class="btn secondary" id="upNow">Upgrades</div>
          <div class="btn secondary" id="rematch">Rematch</div>
        </div>
        `,
        `<div class="btn secondary" id="close">Close</div>`
      );
      document.getElementById("close").onclick = () => { hideModal(); els.btnMenu.click(); };
      document.getElementById("rematch").onclick = () => { hideModal(); startMatch(); };
      document.getElementById("openNow").onclick = () => renderChests();
      document.getElementById("upNow").onclick = () => renderUpgrades();

    } else {
      save.stats.totalLosses += 1;
      save.streak = 0;

      // Ranked % loss (Bronze+). Bronze/Silver loss is tiny.
      if(save.rankIndex >= 1){
        const rk = currentRank();
        save.rankPct -= rankLossPct(rk.id);
        // Demote if below 0%
        while(save.rankPct < 0 && save.rankIndex > 0){
          save.rankIndex -= 1;
          save.rankPct += 100;
        }
        save.rankPct = Math.max(0, Math.min(99.9, save.rankPct));
      }

      persist(); updateTopbar();
      showModal(
        "Defeat ðŸ’€",
        `
        <p>Grind tip: open chests for more gold, then use Upgrades to level your best cards.</p>
        <div class="row">
          <span class="pill bad">LOSS</span>
          <span class="pill">Bot: <b>${save.lastBot.name}</b> Â· <b>${save.lastBot.personality}</b></span>
          <span class="pill">Rank %: <b>${save.rankPct.toFixed(1)}%</b></span>
          <span class="pill">Best streak: <b>${save.bestStreak}</b></span>
        </div>
        <div class="grid3" style="margin-top:10px">
          <div class="btn" id="deck">Deck Builder</div>
          <div class="btn secondary" id="up">Upgrades</div>
          <div class="btn secondary" id="rematch2">Rematch</div>
        </div>
        `,
        `<div class="btn secondary" id="close2">Close</div>`
      );
      document.getElementById("close2").onclick = () => { hideModal(); els.btnMenu.click(); };
      document.getElementById("rematch2").onclick = () => { hideModal(); startMatch(); };
      document.getElementById("deck").onclick = () => renderDeckBuilder();
      document.getElementById("up").onclick = () => renderUpgrades();
    }
  }

  // Topbar buttons
  els.btnChests.onclick = renderChests;
  els.btnUpgrades.onclick = renderUpgrades;
  els.btnDeck.onclick = renderDeckBuilder;

  updateTopbar();
  renderHome();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
